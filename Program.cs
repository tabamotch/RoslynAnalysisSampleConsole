using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace RoslynAnalysisSampleConsole
{
    class Program
    {
        private const string ARG_HINT_SINGLE_SOURCE = "/singlesource";
        
        private const string TEST_SOURCE_PATH = @"D:\Projects\SampleConsole1";
        private const string TEST_DLL_PATH = @"D:\Projects\SampleConsole1\bin\Debug";

        private static string _executingAsmPath = string.Empty;

        private static readonly string[] _exceptDirs = { @"\obj\" };

        private static string[] _autoGeneratedFiles;
        private static string[] _exceptNamespacesStartsWith;

        private static readonly string[] _loadingAssemblyDirs =
        {
            // ここは見直す必要有り
            //@"C:\Program Files (x86)\Reference Assemblies\Microsoft\Framework\.NETFramework\v4.0\"
        };

        static void Main(string[] args)
        {
            // EXE実行中のパスを取得
            _executingAsmPath = Directory.GetParent(Assembly.GetExecutingAssembly().Location).FullName;

            string _sourceDirPath = null;
            string _dllPath = null;

            bool isSingleSource = false;

            if (args.Length == 0)
            {
                // デバッグ用
                //isSingleSource = true;

                // テスト用
                _sourceDirPath = TEST_SOURCE_PATH;
                _dllPath = TEST_DLL_PATH;
            }
            else if (args.Length < 2)
            {
                Console.Error.WriteLine("使い方①： RoslynAnalysisSampleConsole [ソース格納ディレクトリパス] [bin格納ディレクトリパス]");
                Console.Error.WriteLine($"使い方②： RoslynAnalysisSampleConsole [ソースファイルパス] [bin格納ディレクトリパス] {ARG_HINT_SINGLE_SOURCE}");
                return;
            }
            else
            {
                _sourceDirPath = args[0];
                _dllPath = args[1];
            }

            if (!isSingleSource)
            {
                foreach (string arg in args)
                {
                    if (arg?.ToLower() == ARG_HINT_SINGLE_SOURCE)
                    {
                        isSingleSource = true;
                        break;
                    }
                }
            }

            if (!isSingleSource && !Directory.Exists(_sourceDirPath))
            {
                Console.Error.WriteLine($"指定されたソース格納ディレクトリパスが見つかりません({_sourceDirPath})");
                return;
            }

            if (isSingleSource && !File.Exists(_sourceDirPath))
            {
                Console.Error.WriteLine($"指定されたソースファイルが見つかりません({_sourceDirPath})");
                return;
            }

            if (!Directory.Exists(_dllPath))
            {
                Console.Error.WriteLine($"指定されたbin格納ディレクトリパスが見つかりません({_sourceDirPath})");
                return;
            }

            try
            {
                _exceptNamespacesStartsWith = new string[Properties.Settings.Default.ExceptNamespacesStartsWith.Count];
                Properties.Settings.Default.ExceptNamespacesStartsWith.CopyTo(_exceptNamespacesStartsWith, 0);

                _autoGeneratedFiles = new string[Properties.Settings.Default.AutoGeneratedFiles.Count];
                Properties.Settings.Default.AutoGeneratedFiles.CopyTo(_autoGeneratedFiles, 0);

                List<PortableExecutableReference> asmList = new List<PortableExecutableReference>();

                FileInfo msCorlib = new FileInfo(typeof(object).Assembly.Location);
                string msCorlibDir = msCorlib.DirectoryName;
                asmList.Add(MetadataReference.CreateFromFile(msCorlib.FullName));

                foreach (string path in Directory.GetFiles(_dllPath)
                    .Where(p => p.EndsWith(".dll") || p.EndsWith(".exe")))
                {
                    var asm = MetadataReference.CreateFromFile(path);
                    asmList.Add(asm);
                }

                List<string> asmDirs = new List<string>();
                asmDirs.Add(msCorlibDir);
                asmDirs.AddRange(_loadingAssemblyDirs);

                foreach (string path in asmDirs)
                {
                    foreach (string asmPath in Directory.GetFiles(path)
                        .Where(p => p.EndsWith(".dll") || p.EndsWith(".exe")))
                    {
                        var asm = MetadataReference.CreateFromFile(asmPath);
                        asmList.Add(asm);
                    }
                }

                if (isSingleSource)
                {
                    SyntaxTree tree;
                    using (TextReader reader = new StreamReader(_sourceDirPath))
                    {
                        tree = CSharpSyntaxTree.ParseText(reader.ReadToEnd());
                    }

                    Dictionary<string, SyntaxTree> dic = new Dictionary<string, SyntaxTree> {{_sourceDirPath, tree}};
                    WriteSingleFileAnalyzeResult(_sourceDirPath, asmList, dic);
                }
                else
                {
                    var sourceFilePathList =
                        from s in Directory.GetFiles(_sourceDirPath, "*.cs", SearchOption.AllDirectories)
                        where !_exceptDirs.Any(s2 => s.ToLower().Contains(s2))
                        select s;

                    Dictionary<string, SyntaxTree> treeDic = new Dictionary<string, SyntaxTree>();

                    var filePathList = sourceFilePathList as string[] ?? sourceFilePathList.ToArray();
                    foreach (string tmpPath in filePathList)
                    {
                        using (TextReader reader = new StreamReader(tmpPath))
                        {
                            treeDic.Add(tmpPath, CSharpSyntaxTree.ParseText(reader.ReadToEnd()));
                        }
                    }

                    foreach (string sourcePath in filePathList)
                    {
                        if(_autoGeneratedFiles.Any(s => sourcePath.ToLower().EndsWith(s)))
                        {
                            continue;
                        }

                        WriteSingleFileAnalyzeResult(sourcePath, asmList, treeDic);
                    }
                }
            }
            catch (Exception ex)
            {
                WriteExceptionLog(ex);
                Environment.Exit(-1);
            }
        }

        /// <summary>
        /// 一つのソースファイルを解析
        /// </summary>
        /// <param name="sourceFilePath">ソースファイルパス</param>
        /// <param name="assemblyList">アセンブリリスト(名前空間・クラス名解決に使用)</param>
        /// <param name="indent">インデント(省略可能)</param>
        private static void WriteSingleFileAnalyzeResult(string sourceFilePath, IEnumerable<PortableExecutableReference> assemblyList,
            Dictionary<string, SyntaxTree> syntaxTreeDic)
        {
            try
            {
                SyntaxTree target = syntaxTreeDic[sourceFilePath];

                var compilation = CSharpCompilation.Create("TypeInfo", syntaxTreeDic.Values, assemblyList);
                var model = compilation.GetSemanticModel(target);

                var root = target.GetRoot();
                var classes = root.DescendantNodes().OfType<ClassDeclarationSyntax>();

                List<ClassMethodInfo> list = new List<ClassMethodInfo>();
                foreach (ClassDeclarationSyntax cls in classes)
                {
                    list.AddRange(GetClassDeclaration(cls, model, sourceFilePath));
                }

                IEnumerable<string> output = CreateClassMethodInfoListOutput(list, sourceFilePath);
                foreach (string line in output)
                {
                    Console.WriteLine(line);
                }
            }
            catch (Exception ex)
            {
                List<string> errorReport = new List<string>();
                errorReport.Add($"AnalyzingSourceFile: {sourceFilePath}");

                WriteExceptionLog(new ApplicationException("[" + string.Join(",", errorReport) + "]", ex));
            }
        }

        private static IEnumerable<string> CreateClassMethodInfoListOutput(IEnumerable<ClassMethodInfo> clsList, string sourceFilePath)
        {
            List<string> result = new List<string>();

            foreach (ClassMethodInfo info in clsList)
            {
                result.AddRange(CreateClassMethodInfoOutput(info, sourceFilePath));
            }

            return result;
        }

        private static IEnumerable<string> CreateClassMethodInfoOutput(ClassMethodInfo info, string sourceFilePath)
        {
            List<string> result = new List<string>();

            if (info.Children != null && info.Children.Any())
            {
                foreach (ClassMethodInfo child in info.Children)
                {
                    string line = sourceFilePath + "\t" + info.MethodName + "\t" + child.MethodName + "\t" +
                                      info.LineCount;
                    result.Add(line);

                    result.AddRange(CreateClassMethodInfoOutput(child, sourceFilePath));
                }
            }
            else if(info.LineCount > 0)
            {
                result.Add(sourceFilePath + "\t" + info.MethodName + "\t\t" + info.LineCount);
            }

            return result;
        }

        /// <summary>
        /// 一つのクラスを解析
        /// </summary>
        /// <param name="cls">クラス定義</param>
        /// <param name="model">セマンティックモデル</param>
        /// <param name="indent">インデント(省略可能)</param>
        private static IEnumerable<ClassMethodInfo> GetClassDeclaration(ClassDeclarationSyntax cls, SemanticModel model, string sourceFilePath)
        {
            string nameSpace = string.Empty;
            string className = string.Empty;

            ClassDeclarationSyntax tmp = cls;
            while (tmp.Parent is ClassDeclarationSyntax syntax1)
            {
                className = tmp.Identifier.Text;
                nameSpace = string.IsNullOrEmpty(nameSpace) ? className : className + "." + nameSpace;

                tmp = syntax1;
            }

            if (cls.Parent is NamespaceDeclarationSyntax syntax2)
            {
                nameSpace = syntax2.Name.ToString() + nameSpace;
            }
            else
            {
                nameSpace = "(名前空間無し)";
            }

            try
            {
                List<ClassMethodInfo> list = new List<ClassMethodInfo>();

                var constructorBlocks = cls.DescendantNodes().OfType<ConstructorDeclarationSyntax>();
                foreach (ConstructorDeclarationSyntax constructorBlock in constructorBlocks)
                {
                    if (sourceFilePath.ToLower().EndsWith(".designer.cs"))
                    {
                        continue;
                    }

                    ClassMethodInfo con = GetConstructorDeclaration(constructorBlock, model, nameSpace,
                        cls.Identifier.Text);

                    list.Add(con);
                }

                var methodBlocks = cls.DescendantNodes().OfType<MethodDeclarationSyntax>();
                foreach (MethodDeclarationSyntax methodBlock in methodBlocks)
                {
                    if (sourceFilePath.ToLower().EndsWith(".designer.cs") &&
                        methodBlock.Identifier.ToString() != "InitializeComponent")
                    {
                        continue;
                    }

                    ClassMethodInfo method = GetMethodDeclaration(methodBlock, model, nameSpace, cls.Identifier.Text);

                    if (methodBlock.Identifier.ToString() == "InitializeComponent")
                    {
                        // InitializeComponentはカウントしない。
                        method.LineCount = 0;
                    }

                    list.Add(method);
                }

                return list;
            }
            catch (Exception ex)
            {
                List<string> errorReport = new List<string>();
                errorReport.Add($"AnalyzingNamespace: {nameSpace}");
                errorReport.Add($"AnalyzingClass: {className}");

                WriteExceptionLog(new ApplicationException("[" + string.Join(",", errorReport) + "]", ex));
            }

            return null;
        }

        /// <summary>
        /// 一つのコンストラクタ定義を解析
        /// </summary>
        /// <param name="constructorBlock">コンストラクタ定義</param>
        /// <param name="model">セマンティックモデル</param>
        /// <param name="nameSpace">呼び出し元クラスの属する名前空間</param>
        /// <param name="className">呼び出し元クラス名</param>
        /// <param name="indent">インデント(省略可能)</param>
        private static ClassMethodInfo GetConstructorDeclaration(ConstructorDeclarationSyntax constructorBlock, SemanticModel model,
            string nameSpace, string className)
        {
            StringBuilder str = new StringBuilder();

            try
            {
                var symbol = model.GetDeclaredSymbol(constructorBlock);

                str.Append("Constructor Declaration: ");
                str.Append("\t");
                str.Append(nameSpace + "." + className);
                str.Append("\t");
                str.Append(constructorBlock.Identifier.Text);

                List<string> paramTypeStrings = new List<string>();
                foreach (var item in constructorBlock.ParameterList.Parameters)
                {
                    paramTypeStrings.Add(model.GetTypeInfo(item.Type).Type.Name);
                }

                str.Append($"({string.Join(",", paramTypeStrings)})");
                str.Append("\t");

                string modifier = constructorBlock.Modifiers.ToString();
                str.Append(modifier);
                str.Append("\t");

                int lineCount = 0;
                using (StringReader sReader = new StringReader(constructorBlock.WithoutTrivia().ToFullString()))
                {
                    string line;
                    while ((line = sReader.ReadLine()) != null)
                    {
                        if (line != string.Empty &&
                            !string.IsNullOrWhiteSpace(line) &&
                            !line.Trim().StartsWith("//"))
                        {
                            lineCount++;
                        }
                    }
                }

                str.Append(lineCount);
                //Console.WriteLine((indent ?? string.Empty) + str);

                IEnumerable<ClassMethodInfo> children = GetCallingMethods(constructorBlock, model, nameSpace, className);

                ClassMethodInfo result = new ClassMethodInfo();
                result.ClassName = symbol.ContainingType.ToString();
                result.MethodName = symbol.OriginalDefinition.ToString();
                result.LineCount = lineCount;
                result.Children.AddRange(children);

                return result;
            }
            catch (Exception ex)
            {
                List<string> errorReport = new List<string>();
                errorReport.Add($"AnalyzingNamespace: {nameSpace}");
                errorReport.Add($"AnalyzingClass: {className}");
                errorReport.Add($"AnalyzingMethod: {constructorBlock.Identifier.Text}");

                WriteExceptionLog(new ApplicationException("[" + string.Join(",", errorReport) + "]", ex));
            }

            return null;
        }

        /// <summary>
        /// 一つのメソッド定義を解析
        /// </summary>
        /// <param name="methodBlock">メソッド定義</param>
        /// <param name="model">セマンティックモデル</param>
        /// <param name="nameSpace">呼び出し元クラスの属する名前空間</param>
        /// <param name="className">呼び出し元クラス名</param>
        /// <param name="indent">インデント(省略可能)</param>
        private static ClassMethodInfo GetMethodDeclaration(MethodDeclarationSyntax methodBlock, SemanticModel model,
            string nameSpace, string className)
        {
            StringBuilder str = new StringBuilder();

            try
            {
                var symbol = model.GetDeclaredSymbol(methodBlock);

                str.Append("Method Declaration: ");
                str.Append("\t");

                if (symbol != null)
                {
                    str.Append(symbol.ContainingType);
                }
                else
                {
                    str.Append(nameSpace + "." + className);
                }
                
                str.Append("\t");
                str.Append(methodBlock.Identifier.Text);

                str.Append(methodBlock.ParameterList);
                str.Append("\t");

                string modifier = methodBlock.Modifiers.ToString();
                str.Append(modifier);
                str.Append("\t");

                int lineCount = 0;
                using (StringReader sReader = new StringReader(methodBlock.WithoutTrivia().ToFullString()))
                {
                    string line;
                    while ((line = sReader.ReadLine()) != null)
                    {
                        if (line != string.Empty &&
                            !string.IsNullOrWhiteSpace(line) &&
                            !line.Trim().StartsWith("//"))
                        {
                            lineCount++;
                        }
                    }
                }

                str.Append(lineCount);
                //Console.WriteLine((indent ?? string.Empty) + str);

                IEnumerable<ClassMethodInfo> children = GetCallingMethods(methodBlock, model, nameSpace, className);

                ClassMethodInfo result = new ClassMethodInfo();
                result.ClassName = symbol.ContainingType.ToString();
                result.MethodName = symbol.OriginalDefinition.ToString();
                result.LineCount = lineCount;
                result.Children.AddRange(children);

                return result;
            }
            catch (Exception ex)
            {
                List<string> errorReport = new List<string>();
                errorReport.Add($"AnalyzingNamespace: {nameSpace}");
                errorReport.Add($"AnalyzingClass: {className}");
                errorReport.Add($"AnalyzingMethod: {methodBlock.Identifier.Text}");

                WriteExceptionLog(new ApplicationException("[" + string.Join(",", errorReport) + "]", ex));
            }

            return null;
        }

        public static IEnumerable<ClassMethodInfo> GetCallingMethods(MethodDeclarationSyntax methodBlock, SemanticModel model,
            string thisNameSpace, string thisClassName)
        {
            var calling = from node in methodBlock.DescendantNodes()
                where node is InvocationExpressionSyntax ||
                      node is ObjectCreationExpressionSyntax ||
                      node is IdentifierNameSyntax
                select node;

            return GetCallingMethods(calling, model, thisNameSpace, thisClassName);
        }

        public static IEnumerable<ClassMethodInfo> GetCallingMethods(ConstructorDeclarationSyntax constructorBlock, SemanticModel model,
            string thisNameSpace, string thisClassName)
        {
            var calling = from node in constructorBlock.DescendantNodes()
                where node is InvocationExpressionSyntax ||
                      node is ObjectCreationExpressionSyntax ||
                      node is IdentifierNameSyntax
                select node;

            return GetCallingMethods(calling, model, thisNameSpace, thisClassName);
        }

        /// <summary>
        /// 一つのメソッド呼び出し結果を出力
        /// </summary>
        /// <param name="methodBlock">呼び出し元のメソッド定義</param>
        /// <param name="model">セマンティックモデル</param>
        /// <param name="thisNameSpace">呼び出し元クラスの属する名前空間</param>
        /// <param name="thisClassName">呼び出し元クラス名</param>
        /// <param name="indent">インデント(省略可能)</param>
        private static IEnumerable<ClassMethodInfo> GetCallingMethods(IEnumerable<SyntaxNode> calling,
            SemanticModel model, string thisNameSpace, string thisClassName)
        {
            List<ClassMethodInfo> result = new List<ClassMethodInfo>();

            foreach(SyntaxNode node in calling)
            {
                if (node is IdentifierNameSyntax ident)
                {
                    var symbol = model.GetSymbolInfo(ident).Symbol;

                    if (symbol == null) continue;
                    if (symbol.Kind != SymbolKind.Method) continue;

                    string nameSpace = symbol.ContainingNamespace.ToString();

                    if (nameSpace == "System")
                    {
                        continue;
                    }

                    if (_exceptNamespacesStartsWith.Any(s => nameSpace.StartsWith(s)))
                    {
                        continue;
                    }

                    ClassMethodInfo cmi = new ClassMethodInfo();
                    cmi.ClassName = symbol.ContainingType.ToString();
                    cmi.MethodName = symbol.OriginalDefinition.ToString();

                    if (cmi.MethodName.Contains("DoApplicationLogic"))
                    {
                        // プロジェクトの特有処理。メソッド名をすり替える
                        cmi.MethodName = cmi.MethodName.Replace("DoApplicationLogic", "DoMain");
                    }

                    if (cmi.MethodName.Contains("DoBusinessLogic"))
                    {
                        // プロジェクトの特有処理。メソッド名をすり替える
                        cmi.MethodName = cmi.MethodName.Replace("DoBusinessLogic", "DoMain");
                    }

                    result.Add(cmi);
                }
                else if (node is ObjectCreationExpressionSyntax objCreate)
                {
                    var symbol = model.GetSymbolInfo(objCreate).Symbol;

                    if (symbol != null)
                    {
                        string nameSpace = symbol.ContainingNamespace.ToString();

                        if (nameSpace == "System")
                        {
                            continue;
                        }

                        if (_exceptNamespacesStartsWith.Any(s => nameSpace.StartsWith(s)))
                        {
                            continue;
                        }
                        
                        ClassMethodInfo cmi = new ClassMethodInfo();
                        cmi.ClassName = symbol.ContainingType.ToString();
                        cmi.MethodName = symbol.OriginalDefinition.ToString();
                        result.Add(cmi);
                    }
                    else
                    {
                        // ここに入ってきた時の対処法が分からない
                    }
                }
            }

            return result;
        }

        private static void WriteExceptionLog(Exception ex)
        {
            DateTime now = DateTime.Now;

            List<string> errorReport = new List<string>();
            errorReport.Add($"出力日付： {now:yyyy/MM/dd}");
            errorReport.Add($"出力時刻： {now:HH:mm:ss}");
            errorReport.Add("詳細情報：");

            errorReport.Add(ex.ToString());

            Exception current = ex;
            while (current.InnerException != null)
            {
                current = current.InnerException;
                errorReport.Add(current.ToString());
                errorReport.Add(current.Message);
                errorReport.Add(current.StackTrace);
            }

            Console.Error.WriteLine(string.Join(Environment.NewLine, errorReport));

            string logOutputPath = Path.Combine(_executingAsmPath, "Exception.log");
            using (StreamWriter writer = new StreamWriter(logOutputPath, true, Encoding.UTF8))
            {
                writer.WriteLine("========================================");
                writer.WriteLine(string.Join(Environment.NewLine, errorReport));
                writer.WriteLine();
            }
        }
    }
}
